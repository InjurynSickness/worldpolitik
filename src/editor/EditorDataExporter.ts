// Export editor state to TypeScript files and JSON
import type { EditableCountry } from './CountryEditor';

export interface ExportOptions {
    includeTimestamp?: boolean;
    formatCode?: boolean;
}

export class EditorDataExporter {
    /**
     * Export provinceAssignments.ts file content
     */
    public static generateProvinceAssignmentsFile(
        provinceOwners: Map<string, string>,
        options: ExportOptions = {}
    ): string {
        const { includeTimestamp = true } = options;

        const timestamp = new Date().toISOString();
        const entries: string[] = [];

        // Sort province IDs numerically for better readability
        const sortedProvinces = Array.from(provinceOwners.entries()).sort((a, b) => {
            const numA = parseInt(a[0]);
            const numB = parseInt(b[0]);
            return numA - numB;
        });

        for (const [provinceId, countryTag] of sortedProvinces) {
            entries.push(`    ["${provinceId}", "${countryTag}"]`);
        }

        const header = includeTimestamp
            ? `// Generated by Country Editor
// Edited on: ${timestamp}
// Total provinces: ${provinceOwners.size}

`
            : '';

        return `${header}/**
 * Maps province IDs to country tags
 * This defines the political ownership of each province
 */
export const provinceToCountryMap = new Map<string, string>([
${entries.join(',\n')}
]);
`;
    }

    /**
     * Export countryData.ts file content
     */
    public static generateCountryDataFile(
        countries: Map<string, EditableCountry>,
        options: ExportOptions = {}
    ): string {
        const { includeTimestamp = true } = options;

        const timestamp = new Date().toISOString();
        const entries: string[] = [];

        // Sort by tag for consistency
        const sortedCountries = Array.from(countries.values()).sort((a, b) =>
            a.tag.localeCompare(b.tag)
        );

        for (const country of sortedCountries) {
            entries.push(`    ["${country.tag}", { name: "${country.name}", color: "${country.color}" }]`);
        }

        const header = includeTimestamp
            ? `// Generated by Country Editor
// Edited on: ${timestamp}
// Total countries: ${countries.size}

`
            : '';

        return `${header}/**
 * Maps country ISO codes to their display names and colors
 */
export interface CountryData {
    name: string;
    color: string;
}

export const allCountryData = new Map<string, CountryData>([
${entries.join(',\n')}
]);

// Backwards compatibility export
export { allCountryData as countryData };
`;
    }

    /**
     * Export editor state as JSON for saving/loading
     */
    public static exportEditorStateJSON(
        countries: Map<string, EditableCountry>,
        provinceOwners: Map<string, string>
    ): string {
        const countriesObj: Record<string, any> = {};

        for (const [tag, country] of countries.entries()) {
            countriesObj[tag] = {
                name: country.name,
                color: country.color,
                provinces: Array.from(country.provinces)
            };
        }

        const provinceOwnersObj: Record<string, string> = {};
        for (const [provinceId, countryTag] of provinceOwners.entries()) {
            provinceOwnersObj[provinceId] = countryTag;
        }

        const state = {
            version: "1.0",
            timestamp: new Date().toISOString(),
            countries: countriesObj,
            provinceOwners: provinceOwnersObj
        };

        return JSON.stringify(state, null, 2);
    }

    /**
     * Import editor state from JSON
     */
    public static importEditorStateJSON(
        jsonString: string
    ): {
        countries: Map<string, EditableCountry>;
        provinceOwners: Map<string, string>;
    } | null {
        try {
            const state = JSON.parse(jsonString);

            if (state.version !== "1.0") {
                console.error('[EditorDataExporter] Unsupported version:', state.version);
                return null;
            }

            const countries = new Map<string, EditableCountry>();
            for (const [tag, data] of Object.entries(state.countries as Record<string, any>)) {
                countries.set(tag, {
                    tag,
                    name: data.name,
                    color: data.color,
                    provinces: new Set(data.provinces)
                });
            }

            const provinceOwners = new Map<string, string>(
                Object.entries(state.provinceOwners as Record<string, string>)
            );

            console.log(`[EditorDataExporter] Imported ${countries.size} countries, ${provinceOwners.size} provinces`);
            return { countries, provinceOwners };

        } catch (error) {
            console.error('[EditorDataExporter] Failed to import JSON:', error);
            return null;
        }
    }

    /**
     * Generate a downloadable blob for file export
     */
    public static createDownloadBlob(content: string, mimeType: string = 'text/plain'): Blob {
        return new Blob([content], { type: mimeType });
    }

    /**
     * Trigger browser download
     */
    public static downloadFile(content: string, filename: string, mimeType: string = 'text/plain'): void {
        const blob = this.createDownloadBlob(content, mimeType);
        const url = URL.createObjectURL(blob);

        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        URL.revokeObjectURL(url);
    }

    /**
     * Export all data as downloadable files
     */
    public static exportAll(
        countries: Map<string, EditableCountry>,
        provinceOwners: Map<string, string>
    ): void {
        // Export provinceAssignments.ts
        const provinceAssignmentsContent = this.generateProvinceAssignmentsFile(provinceOwners);
        this.downloadFile(provinceAssignmentsContent, 'provinceAssignments.ts', 'text/typescript');

        // Export countryData.ts
        const countryDataContent = this.generateCountryDataFile(countries);
        this.downloadFile(countryDataContent, 'countryData.ts', 'text/typescript');

        // Export JSON state
        const jsonContent = this.exportEditorStateJSON(countries, provinceOwners);
        this.downloadFile(jsonContent, 'editor_state.json', 'application/json');

        console.log('[EditorDataExporter] Exported all files');
    }

    /**
     * Validate editor state before export
     */
    public static validateState(
        countries: Map<string, EditableCountry>,
        provinceOwners: Map<string, string>
    ): { valid: boolean; errors: string[] } {
        const errors: string[] = [];

        // Check for orphaned provinces (assigned to non-existent countries)
        for (const [provinceId, countryTag] of provinceOwners.entries()) {
            if (!countries.has(countryTag)) {
                errors.push(`Province ${provinceId} assigned to non-existent country ${countryTag}`);
            }
        }

        // Check for duplicate colors (warning, not error)
        const colorMap = new Map<string, string[]>();
        for (const [tag, country] of countries.entries()) {
            const existing = colorMap.get(country.color);
            if (existing) {
                existing.push(tag);
            } else {
                colorMap.set(country.color, [tag]);
            }
        }

        for (const [color, tags] of colorMap.entries()) {
            if (tags.length > 1) {
                errors.push(`Warning: Color ${color} used by multiple countries: ${tags.join(', ')}`);
            }
        }

        // Check country data consistency
        for (const [tag, country] of countries.entries()) {
            // Verify province sets match provinceOwners
            const ownedProvinces = Array.from(provinceOwners.entries())
                .filter(([_, owner]) => owner === tag)
                .map(([id, _]) => id);

            const countryProvinces = Array.from(country.provinces);

            if (ownedProvinces.length !== countryProvinces.length) {
                errors.push(`Country ${tag}: province count mismatch (${ownedProvinces.length} owned, ${countryProvinces.length} in set)`);
            }
        }

        return {
            valid: errors.length === 0 || errors.every(e => e.startsWith('Warning:')),
            errors
        };
    }

    /**
     * Generate statistics about the current state
     */
    public static generateStatistics(
        countries: Map<string, EditableCountry>,
        provinceOwners: Map<string, string>
    ): {
        totalCountries: number;
        totalProvinces: number;
        averageProvincesPerCountry: number;
        largestCountry: { tag: string; name: string; provinces: number } | null;
        smallestCountry: { tag: string; name: string; provinces: number } | null;
        unassignedProvinces: number;
    } {
        const totalCountries = countries.size;
        const totalProvinces = provinceOwners.size;
        const averageProvincesPerCountry = totalCountries > 0
            ? Math.round(totalProvinces / totalCountries)
            : 0;

        let largest: { tag: string; name: string; provinces: number } | null = null;
        let smallest: { tag: string; name: string; provinces: number } | null = null;

        for (const country of countries.values()) {
            const provinceCount = country.provinces.size;

            if (provinceCount > 0) {
                if (!largest || provinceCount > largest.provinces) {
                    largest = { tag: country.tag, name: country.name, provinces: provinceCount };
                }
                if (!smallest || provinceCount < smallest.provinces) {
                    smallest = { tag: country.tag, name: country.name, provinces: provinceCount };
                }
            }
        }

        // This would require total province count from the map
        const unassignedProvinces = 0; // TODO: Calculate from total provinces

        return {
            totalCountries,
            totalProvinces,
            averageProvincesPerCountry,
            largestCountry: largest,
            smallestCountry: smallest,
            unassignedProvinces
        };
    }
}
